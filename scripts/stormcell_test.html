<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stormcell Viewer Test</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        html, body { height: 100%; margin: 0; padding: 0; }
        #map { height: 100%; width: 100%; }
        /* Custom scrollbar for webkit */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 h-screen flex overflow-hidden font-sans">

    <!-- Sidebar -->
    <div class="w-80 flex-shrink-0 flex flex-col border-r border-gray-700 bg-gray-800">
        <div class="p-4 border-b border-gray-700">
            <h1 class="text-xl font-bold mb-4 text-blue-400">Stormcell Test</h1>
            
            <div class="space-y-3">
                <div>
                    <label class="block text-xs text-gray-400 mb-1">API Server URL</label>
                    <input type="text" id="apiUrl" value="http://localhost:5000" class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm focus:outline-none focus:border-blue-500 transition-colors">
                </div>
                <button id="connectBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded transition-colors text-sm">
                    Connect & Fetch List
                </button>
            </div>
        </div>

        <!-- List Container -->
        <!-- Slider Container -->
        <div id="sliderContainer" class="flex-1 flex flex-col justify-end p-4 space-y-4 hidden">
            <div class="text-center">
                <div class="text-gray-400 text-xs uppercase tracking-wide mb-1">Current Time</div>
                <div id="timeDisplay" class="text-xl font-mono text-blue-300 font-bold">--:--</div>
                <div id="dateDisplay" class="text-xs text-gray-500">YYYY-MM-DD</div>
            </div>

            <div class="relative w-full h-12 flex items-center">
                <input type="range" id="timeSlider" min="0" max="100" value="0" step="1" 
                    class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer focus:outline-none focus:ring-2 focus:ring-blue-600 accent-blue-500">
            </div>
            
            <div class="flex justify-between text-xs text-gray-600">
                <span id="startTime">Start</span>
                <span id="endTime">End</span>
            </div>
        </div>

        <div id="statusMsg" class="flex-1 flex items-center justify-center p-4 text-gray-500 text-sm italic">
            Not connected.
        </div>
    </div>

    <!-- Main Map Area -->
    <div class="flex-1 relative">
        <div id="map" class="z-0"></div>
        
        <!-- Info Overlay -->
        <div class="absolute top-4 right-4 z-[1000] bg-gray-800/90 backdrop-blur border border-gray-600 rounded p-4 max-w-xs shadow-lg hidden" id="infoPanel">
            <h3 class="font-bold text-lg mb-2 text-blue-300" id="infoTitle">Selected Cell</h3>
            <pre id="infoContent" class="text-xs overflow-auto max-h-60 text-gray-300"></pre>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- EdgeWARN API Client -->
    <script src="../utils/edgewarn-api.js"></script>
    <script>
        // Init Map
        // Center on US approximately
        const map = L.map('map').setView([37.8, -96], 4);

        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd',
            maxZoom: 20
        }).addTo(map);

        // State
        let currentLayer = null;

        // Elements
        const apiUrlInput = document.getElementById('apiUrl');
        const connectBtn = document.getElementById('connectBtn');
        const sliderContainer = document.getElementById('sliderContainer');
        const statusMsg = document.getElementById('statusMsg');
        const timeSlider = document.getElementById('timeSlider');
        const timeDisplay = document.getElementById('timeDisplay');
        const dateDisplay = document.getElementById('dateDisplay');
        // State
        let allTimestamps = [];

        // Logic
        connectBtn.addEventListener('click', async () => {
            const baseUrl = apiUrlInput.value.replace(/\/$/, '');
            const apiClient = new EdgeWARNAPI(baseUrl);
            
            connectBtn.disabled = true;
            connectBtn.textContent = 'Fetching...';
            statusMsg.textContent = 'Loading timestamps...';
            statusMsg.classList.remove('hidden');
            sliderContainer.classList.add('hidden');

            try {
                const timestamps = await apiClient.fetchTimestamps();
                setupSlider(timestamps, apiClient);
            } catch (error) {
                console.error('Error:', error);
                statusMsg.innerHTML = `<span class="text-red-400">Error: ${error.message}</span>`;
            } finally {
                connectBtn.disabled = false;
                connectBtn.textContent = 'Connect & Fetch List';
            }
        });

        function formatTimeLabel(ts) {
            // YYYYMMDD-HHMMSS
            const match = ts.match(/(\d{4})(\d{2})(\d{2})-(\d{2})(\d{2})(\d{2})/);
            if (!match) return { date: ts, time: '' };
            return {
                date: `${match[1]}-${match[2]}-${match[3]}`,
                time: `${match[4]}:${match[5]}:${match[6]}`
            };
        }

        function updateDisplay(index) {
            if (!allTimestamps[index]) return;
            const ts = allTimestamps[index];
            const fmt = formatTimeLabel(ts);
            timeDisplay.textContent = fmt.time;
            dateDisplay.textContent = fmt.date;
        }

        function setupSlider(timestamps, apiClient) {
            // Sort chronological
            allTimestamps = Array.isArray(timestamps) ? timestamps.sort() : [];

            if (allTimestamps.length === 0) {
                statusMsg.textContent = 'No stormcell timestamps found.';
                return;
            }

            statusMsg.classList.add('hidden');
            sliderContainer.classList.remove('hidden');

            // Config slider
            timeSlider.min = 0;
            timeSlider.max = allTimestamps.length - 1;
            timeSlider.value = 0; // Start at beginning? Or end? Let's do beginning.

            // Set start/end labels
            const startFmt = formatTimeLabel(allTimestamps[0]);
            const endFmt = formatTimeLabel(allTimestamps[allTimestamps.length - 1]);
            document.getElementById('startTime').textContent = startFmt.time;
            document.getElementById('endTime').textContent = endFmt.time;

            // Initial display
            updateDisplay(0);
            loadStormCell(apiClient, allTimestamps[0]);

            // Event listener
            timeSlider.oninput = (e) => {
                const idx = parseInt(e.target.value);
                updateDisplay(idx);
            };

            timeSlider.onchange = (e) => {
                const idx = parseInt(e.target.value);
                loadStormCell(apiClient, allTimestamps[idx]);
            };
        }

        async function loadStormCell(apiClient, timestamp) {
            try {
                const data = await apiClient.downloadStormcellList(timestamp);
                console.log("Received Data:", JSON.stringify(data, null, 2)); // Debug log
                renderData(data);
                
                // Show info
                infoPanel.classList.remove('hidden');
                infoContent.textContent = JSON.stringify({
                    timestamp: timestamp,
                    featureCount: data.features ? data.features.length : 'N/A'
                }, null, 2);

            } catch (error) {
                console.error('Error loading cell:', error);
                alert(`Error loading cell data:\n${error.message}`);
            }
        }

        function renderData(data) {
            console.log("RenderData input:", data);
            if (currentLayer) {
                map.removeLayer(currentLayer);
            }

            // Create a feature group
            currentLayer = L.featureGroup().addTo(map);

            // Handle potential wrappers: data.content, data.features, or data itself
            let features = [];
            if (data.content && data.content.features) {
                features = data.content.features;
            } else if (data.features) {
                features = data.features;
            } else if (Array.isArray(data)) {
                features = data;
            }

            console.log(`Found ${features.length} features to render.`);

            // Styles
            const polyStyle = {
                color: "#f87171", // red-400
                weight: 2,
                opacity: 1,
                fillOpacity: 0.3
            };

            features.forEach(cell => {
                if (cell.bbox && Array.isArray(cell.bbox) && cell.bbox.length > 0) {
                    // bbox is [[lat, lon], ...]
                    // L.polygon expects [[lat, lon], ...]
                    // We just need to fix longitude > 180
                    const coords = cell.bbox.map(p => {
                        let lat = p[0];
                        let lon = p[1];
                        if (lon > 180) lon -= 360; 
                        return [lat, lon];
                    });

                    const polygon = L.polygon(coords, polyStyle);
                    
                    if (cell.properties) {
                        const props = { ...cell.properties, id: cell.id };
                        const content = Object.keys(props).map(k => `<b>${k}:</b> ${props[k]}`).join('<br>');
                        polygon.bindPopup(`<div class="text-xs max-h-40 overflow-auto">${content}</div>`);
                        
                        // Sidebar click
                        polygon.on('click', () => {
                             infoPanel.classList.remove('hidden');
                             infoContent.textContent = JSON.stringify(props, null, 2);
                        });
                    }
                    
                    polygon.addTo(currentLayer);
                }
            });

            // Fit bounds if has data
            if (currentLayer.getLayers().length > 0) {
                map.fitBounds(currentLayer.getBounds(), { padding: [50, 50] });
            } else {
                console.warn("No valid polygons created from data.");
            }
        }
    </script>
</body>
</html>
