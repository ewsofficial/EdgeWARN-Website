<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stormcell Viewer Test</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        html, body { height: 100%; margin: 0; padding: 0; }
        #map { height: 100%; width: 100%; }
        /* Custom scrollbar for webkit */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        
        /* Image rendering modes */
        .pixelated-overlay {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 h-screen flex overflow-hidden font-sans">

    <!-- Sidebar -->
    <div class="w-80 flex-shrink-0 flex flex-col border-r border-gray-700 bg-gray-800">
        <div class="p-4 border-b border-gray-700">
            <h1 class="text-xl font-bold mb-4 text-blue-400">Stormcell Test</h1>
            
            <div class="space-y-3">
                <div>
                    <label class="block text-xs text-gray-400 mb-1">API Server URL</label>
                    <input type="text" id="apiUrl" value="http://localhost:5000" class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm focus:outline-none focus:border-blue-500 transition-colors">
                </div>
                <button id="connectBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded transition-colors text-sm">
                    Connect & Fetch List
                </button>
            </div>
        </div>

        <!-- List Container -->
        <!-- Slider Container -->
        <div id="sliderContainer" class="flex-1 flex flex-col justify-end p-4 space-y-4 hidden">
            <div class="text-center">
                <div class="text-gray-400 text-xs uppercase tracking-wide mb-1">Current Time</div>
                <div id="timeDisplay" class="text-xl font-mono text-blue-300 font-bold">--:--</div>
                <div id="dateDisplay" class="text-xs text-gray-500">YYYY-MM-DD</div>
            </div>

            <div class="relative w-full h-12 flex items-center">
                <input type="range" id="timeSlider" min="0" max="100" value="0" step="1" 
                    class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer focus:outline-none focus:ring-2 focus:ring-blue-600 accent-blue-500">
            </div>
            
            <div class="flex justify-between text-xs text-gray-600">
                <span id="startTime">Start</span>
                <span id="endTime">End</span>
            </div>
        </div>

        <div id="statusMsg" class="flex-1 flex items-center justify-center p-4 text-gray-500 text-sm italic">
            Not connected.
        </div>
    </div>

    <!-- Main Map Area -->
    <div class="flex-1 relative">
        <div id="map" class="z-0"></div>
        
        <!-- Info Overlay -->
        <div class="absolute top-4 right-4 z-[1000] bg-gray-800/90 backdrop-blur border border-gray-600 rounded p-4 max-w-xs shadow-lg hidden" id="infoPanel">
            <h3 class="font-bold text-lg mb-2 text-blue-300" id="infoTitle">Selected Cell</h3>
            <pre id="infoContent" class="text-xs overflow-auto max-h-60 text-gray-300"></pre>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- EdgeWARN API Client -->
    <script src="../utils/edgewarn-api.js"></script>
    <script src="../utils/ewmrs.js"></script>
    <script>
        // Init Map
        // Center on US approximately
        const map = L.map('map').setView([37.8, -96], 4);

        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd',
            maxZoom: 20
        }).addTo(map);

        // State
        let currentLayer = null;
        let imageOverlay = null; // Store the image overlay
        let contourLayer = null; // Store boundary contour

        // Elements
        const apiUrlInput = document.getElementById('apiUrl');
        // New Inputs for EWMRS
        const rendersUrlInput = document.createElement('input');
        rendersUrlInput.type = 'text';
        rendersUrlInput.value = 'http://localhost:3003';
        rendersUrlInput.className = 'w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm focus:outline-none focus:border-blue-500 transition-colors mt-2';
        rendersUrlInput.placeholder = 'EWMRS API URL (e.g. :3003)';
        
        const productSelect = document.createElement('select');
        productSelect.className = 'w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm focus:outline-none focus:border-blue-500 transition-colors mt-2 hidden';
        
        const showRadarCheckbox = document.createElement('input');
        showRadarCheckbox.type = 'checkbox';
        showRadarCheckbox.checked = true;
        showRadarCheckbox.className = 'mr-2';
        const showRadarLabel = document.createElement('label');
        showRadarLabel.className = 'text-gray-400 text-xs flex items-center mt-2 hidden';
        showRadarLabel.appendChild(showRadarCheckbox);
        showRadarLabel.appendChild(document.createTextNode('Show Radar Layer'));

        // Inject new inputs
        const inputContainer = apiUrlInput.parentElement;
        inputContainer.appendChild(rendersUrlInput);
        inputContainer.appendChild(productSelect);
        inputContainer.appendChild(showRadarLabel);
        
        // Latitude offset control
        const offsetContainer = document.createElement('div');
        offsetContainer.className = 'mt-2 hidden';
        offsetContainer.id = 'offsetContainer';
        
        const offsetLabel = document.createElement('label');
        offsetLabel.className = 'block text-xs text-gray-400 mb-1';
        offsetLabel.textContent = 'Latitude Offset (degrees)';
        
        const offsetInput = document.createElement('input');
        offsetInput.type = 'number';
        offsetInput.step = '0.1';
        offsetInput.value = '0';
        offsetInput.id = 'latOffset';
        offsetInput.className = 'w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm focus:outline-none focus:border-blue-500 transition-colors';
        
        offsetContainer.appendChild(offsetLabel);
        offsetContainer.appendChild(offsetInput);
        inputContainer.appendChild(offsetContainer);

        // Bounds Box Control
        const showBoundsCheckbox = document.createElement('input');
        showBoundsCheckbox.type = 'checkbox';
        showBoundsCheckbox.className = 'mr-2';
        const showBoundsLabel = document.createElement('label');
        showBoundsLabel.className = 'text-gray-400 text-xs flex items-center mt-2';
        showBoundsLabel.appendChild(showBoundsCheckbox);
        showBoundsLabel.appendChild(document.createTextNode('Show Reference Bounds'));
        inputContainer.appendChild(showBoundsLabel);
        
        // Quality Control
        const crispCheckbox = document.createElement('input');
        crispCheckbox.type = 'checkbox';
        crispCheckbox.checked = true; // Default to crisp for radar data
        crispCheckbox.className = 'mr-2';
        const crispLabel = document.createElement('label');
        crispLabel.className = 'text-gray-400 text-xs flex items-center mt-2';
        crispLabel.appendChild(crispCheckbox);
        crispLabel.appendChild(document.createTextNode('Crisp Rendering (Pixelated)'));
        inputContainer.appendChild(crispLabel);

        // Image Contour Control
        const showContourCheckbox = document.createElement('input');
        showContourCheckbox.type = 'checkbox';
        showContourCheckbox.className = 'mr-2';
        const showContourLabel = document.createElement('label');
        showContourLabel.className = 'text-gray-400 text-xs flex items-center mt-2';
        showContourLabel.appendChild(showContourCheckbox);
        showContourLabel.appendChild(document.createTextNode('Show Image Contour'));
        inputContainer.appendChild(showContourLabel);
        
        // Reference Box
        const referenceBounds = [[20, -130], [55, -60]];
        const boundsLayer = L.rectangle(referenceBounds, {
            color: "#3b82f6", // blue
            weight: 1,
            fill: false,
            dashArray: '4, 4'
        });
        
        // Re-render layer when quality changes
        crispCheckbox.onchange = () => {
             if (imageOverlay) {
                 const el = imageOverlay.getElement();
                 if (el) {
                     if (crispCheckbox.checked) {
                         el.classList.add('pixelated-overlay');
                     } else {
                         el.classList.remove('pixelated-overlay');
                     }
                 }
             }
        };
        
        // Trigger re-render for contour when checked
        showContourCheckbox.onchange = () => {
             if (allTimestamps.length > 0) {
                  const idx = parseInt(timeSlider.value);
                  updateRenderLayer(allTimestamps[idx]);
             }
        };
        
        showBoundsCheckbox.onchange = () => {
            if (showBoundsCheckbox.checked) {
                boundsLayer.addTo(map);
            } else {
                if (map.hasLayer(boundsLayer)) map.removeLayer(boundsLayer);
            }
        };

        const connectBtn = document.getElementById('connectBtn');
        const sliderContainer = document.getElementById('sliderContainer');
        const statusMsg = document.getElementById('statusMsg');
        const timeSlider = document.getElementById('timeSlider');
        const timeDisplay = document.getElementById('timeDisplay');
        const dateDisplay = document.getElementById('dateDisplay');
        
        // State
        let allTimestamps = [];
        let currentlySelectedProduct = null;
        let ewmrsClient = null;
        let productTimestamps = []; // Store timestamps for the selected product

        // Logic
        connectBtn.addEventListener('click', async () => {
            const baseUrl = apiUrlInput.value.replace(/\/$/, '');
            const rendersUrl = rendersUrlInput.value.replace(/\/$/, '');
            
            const apiClient = new EdgeWARNAPI(baseUrl);
            ewmrsClient = new EWMRSAPI(rendersUrl);
            
            connectBtn.disabled = true;
            connectBtn.textContent = 'Fetching...';
            statusMsg.textContent = 'Loading resources...';
            statusMsg.classList.remove('hidden');
            sliderContainer.classList.add('hidden');
            productSelect.classList.add('hidden');
            showRadarLabel.classList.add('hidden');

            try {
                // Fetch stormcell timestamps
                const timestamps = await apiClient.fetchTimestamps();
                
                // Fetch available products
                try {
                    const products = await ewmrsClient.getAvailableProducts();
                    if (products && products.length > 0) {
                        productSelect.innerHTML = '';
                        products.forEach(p => {
                            const opt = document.createElement('option');
                            opt.value = p;
                            opt.text = p;
                            productSelect.appendChild(opt);
                        });
                        productSelect.classList.remove('hidden');
                        showRadarLabel.classList.remove('hidden');
                        document.getElementById('offsetContainer').classList.remove('hidden');
                        
                        // Prefer CompRefQC if available, otherwise first
                        const preferred = "CompRefQC";
                        if (products.includes(preferred)) {
                            productSelect.value = preferred;
                            currentlySelectedProduct = preferred;
                        } else {
                            currentlySelectedProduct = products[0];
                        }
                        
                        // Fetch timestamps for the initial product
                        await fetchProductTimestamps(currentlySelectedProduct);

                        productSelect.onchange = async () => {
                             currentlySelectedProduct = productSelect.value;
                             await fetchProductTimestamps(currentlySelectedProduct);
                             // Trigger reload if we have a valid timestamp
                             if (allTimestamps.length > 0) {
                                  const idx = parseInt(timeSlider.value);
                                  updateRenderLayer(allTimestamps[idx]);
                             }
                        };
                    }
                } catch (e) {
                    console.warn("Could not connect to EWMRS API:", e);
                    // Don't fail the whole thing, just don't show products
                }

                setupSlider(timestamps, apiClient);
            } catch (error) {
                console.error('Error:', error);
                statusMsg.innerHTML = `<span class="text-red-400">Error: ${error.message}</span>`;
            } finally {
                connectBtn.disabled = false;
                connectBtn.textContent = 'Connect & Fetch List';
            }
        });

        async function fetchProductTimestamps(product) {
            try {
                if (ewmrsClient) {
                    productTimestamps = await ewmrsClient.getProductTimestamps(product);
                    productTimestamps.sort(); // Ensure sorted
                    console.log(`Loaded ${productTimestamps.length} timestamps for ${product}`);
                }
            } catch (e) {
                console.warn(`Failed to fetch timestamps for ${product}:`, e);
                productTimestamps = [];
            }
        }

        function formatTimeLabel(ts) {
            // YYYYMMDD-HHMMSS
            const match = ts.match(/(\d{4})(\d{2})(\d{2})-(\d{2})(\d{2})(\d{2})/);
            if (!match) return { date: ts, time: '' };
            return {
                date: `${match[1]}-${match[2]}-${match[3]}`,
                time: `${match[4]}:${match[5]}` // Truncated seconds
            };
        }
        
        function parseTimestamp(ts) {
            // YYYYMMDD-HHMMSS to Date object
             const match = ts.match(/(\d{4})(\d{2})(\d{2})-(\d{2})(\d{2})(\d{2})/);
             if (!match) return null;
             return new Date(
                 parseInt(match[1]), parseInt(match[2]) - 1, parseInt(match[3]),
                 parseInt(match[4]), parseInt(match[5]), parseInt(match[6])
             );
        }

        function findClosestTimestamp(targetTs, candidates) {
            if (!candidates || candidates.length === 0) return null;
            
            const targetDate = parseTimestamp(targetTs);
            if (!targetDate) return null;
            
            // Truncate seconds for matching as requested
            targetDate.setSeconds(0, 0);

            let closest = null;
            let minDiff = Infinity;
            
            for (const cand of candidates) {
                const candDate = parseTimestamp(cand);
                if (!candDate) continue;
                
                // Also truncate candidate seconds to be safe/consistent
                candDate.setSeconds(0, 0);

                const diff = Math.abs(candDate - targetDate);
                if (diff < minDiff) {
                    minDiff = diff;
                    closest = cand;
                }
            }
            
            // Allow a tolerance? e.g. 10 minutes (600000 ms)
            if (minDiff > 600000) {
                console.warn(`Closest timestamp for ${targetTs} is ${closest} (diff: ${minDiff}ms), which is too far.`);
                return null;
            }
            
            return closest;
        }

        function updateDisplay(index) {
            if (!allTimestamps[index]) return;
            const ts = allTimestamps[index];
            const fmt = formatTimeLabel(ts);
            timeDisplay.textContent = fmt.time;
            dateDisplay.textContent = fmt.date;
        }

        function setupSlider(timestamps, apiClient) {
            // Sort chronological
            allTimestamps = Array.isArray(timestamps) ? timestamps.sort() : [];

            if (allTimestamps.length === 0) {
                statusMsg.textContent = 'No stormcell timestamps found.';
                return;
            }

            statusMsg.classList.add('hidden');
            sliderContainer.classList.remove('hidden');

            // Config slider
            timeSlider.min = 0;
            timeSlider.max = allTimestamps.length - 1;
            // Start at end (latest available data) to avoid stale index 404s
            const lastIdx = allTimestamps.length - 1;
            timeSlider.value = lastIdx; 

            // Set start/end labels
            const startFmt = formatTimeLabel(allTimestamps[0]);
            const endFmt = formatTimeLabel(allTimestamps[lastIdx]);
            document.getElementById('startTime').textContent = startFmt.time;
            document.getElementById('endTime').textContent = endFmt.time;

            // Initial display
            updateDisplay(lastIdx);
            loadStormCell(apiClient, allTimestamps[lastIdx]);
            updateRenderLayer(allTimestamps[lastIdx]);

            // Debounce helper to limit API calls
            const debounce = (func, wait) => {
                let timeout;
                return (...args) => {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(this, args), wait);
                };
            };

            const debouncedLoad = debounce((idx) => {
                const ts = allTimestamps[idx];
                loadStormCell(apiClient, ts);
                updateRenderLayer(ts);
            }, 200);

            // Event listener
            timeSlider.oninput = (e) => {
                const idx = parseInt(e.target.value);
                updateDisplay(idx);
                debouncedLoad(idx);
            };
            
            // Re-update layer when checkbox toggled
            showRadarCheckbox.onchange = () => {
                if(allTimestamps.length > 0) {
                    const idx = parseInt(timeSlider.value);
                    updateRenderLayer(allTimestamps[idx]);
                }
            }

            // Remove onchange as we use debounced oninput now
            timeSlider.onchange = null;
        }

        async function updateRenderLayer(timestamp) {
            // Clear existing if unchecked or no product
            if (!showRadarCheckbox.checked || !currentlySelectedProduct || !ewmrsClient) {
                if (imageOverlay) {
                    map.removeLayer(imageOverlay);
                    imageOverlay = null;
                }
                return;
            }
            
            if (productTimestamps.length > 0) {
                 const match = findClosestTimestamp(timestamp, productTimestamps);
                 if (match) {
                     bestTimestamp = match;
                     console.log(`Matched target ${timestamp} to available ${bestTimestamp}`);
                 } else {
                     console.warn(`No timestamp match found for ${timestamp} within tolerance.`);
                     if (imageOverlay) {
                         map.removeLayer(imageOverlay);
                         imageOverlay = null;
                     }
                     return;
                 }
            } else {
                console.warn("No product timestamps available, attempting direct load.");
            }

            const directUrl = ewmrsClient.getRenderUrl(currentlySelectedProduct, bestTimestamp);
            const url = `/proxy-render?url=${encodeURIComponent(directUrl)}`;
            // console.log(`Attempting to load overlay from: ${url}`);
            
            // diagnostic check
            try {
                const resp = await fetch(url, { method: 'HEAD' });
                if (!resp.ok) {
                    console.error(`Image URL check failed: ${resp.status} ${resp.statusText}`);
                    // return; // Let it try anyway so valid 404s show up? No, cleaner to not show broken image.
                    if (imageOverlay) map.removeLayer(imageOverlay);
                    return;
                }
                console.log("Image URL check OK");
            } catch (err) {
                 console.error("Image URL network check failed:", err);
            }
            
            // Get latitude offset from input
            const latOffset = parseFloat(document.getElementById('latOffset').value) || 0;
            
            // Base bounds: [[south, west], [north, east]]
            const baseSouth = 20;
            const baseNorth = 55;
            const baseWest = -130;
            const baseEast = -60;
            
            // Apply offset to latitude bounds
            const bounds = [[baseSouth + latOffset, baseWest], [baseNorth + latOffset, baseEast]];

            if (imageOverlay) {
                // Need to remove and recreate to update bounds
                map.removeLayer(imageOverlay);
            }
            imageOverlay = L.imageOverlay(url, bounds, { opacity: 0.6 }).addTo(map);
            imageOverlay.bringToBack(); // Keep it below polygons
            
            // Apply crisp rendering if checked
            const crispCheckbox = document.getElementById('inputContainer') ? 
                document.getElementById('inputContainer').querySelector('input[type=checkbox]') : null; // Hard to find without ID.
            
            // Easier way: store ref in higher scope or use query selector based on text/class.
            // Or just check the element we just created:
            const crispBox = Array.from(document.querySelectorAll('label')).find(l => l.textContent.includes('Crisp'))?.querySelector('input');
            
            if (crispBox && crispBox.checked) {
                 const el = imageOverlay.getElement();
                 if (el) el.classList.add('pixelated-overlay');
            }

            // Update contour
            if (contourLayer) {
                map.removeLayer(contourLayer);
                contourLayer = null;
            }
            
            const contourBox = Array.from(document.querySelectorAll('label')).find(l => l.textContent.includes('Show Image Contour'))?.querySelector('input');
            if (contourBox && contourBox.checked) {
                contourLayer = L.rectangle(bounds, {
                    color: "#f59e0b", // amber/orange
                    weight: 2,
                    fill: false,
                    dashArray: null
                }).addTo(map);
            }
        }
        
        // Add listener for offset changes
        document.getElementById('latOffset').addEventListener('change', () => {
            if (allTimestamps.length > 0) {
                const idx = parseInt(timeSlider.value);
                updateRenderLayer(allTimestamps[idx]);
            }
        });

        async function loadStormCell(apiClient, timestamp) {
            try {
                const data = await apiClient.downloadStormcellList(timestamp);
                // console.log("Received Data:", JSON.stringify(data, null, 2)); // Debug log
                renderData(data);
                
                // Show info
                const infoPanel = document.getElementById('infoPanel');
                const infoContent = document.getElementById('infoContent');
                
                infoPanel.classList.remove('hidden');
                infoContent.textContent = JSON.stringify({
                    timestamp: timestamp,
                    featureCount: data.features ? data.features.length : 'N/A'
                }, null, 2);

            } catch (error) {
                console.warn(`Error loading cell data for ${timestamp}:`, error);
                
                // Clear map if error
                if (currentLayer) {
                     map.removeLayer(currentLayer);
                     currentLayer = null;
                }

                // If it's a 404/missing file, just clear the map and show a status, don't popup alert
                if (error.message.includes('404') || error.message.includes('not found')) {
                    statusMsg.textContent = `Data not available for ${timestamp} (likely cleaned up).`;
                    statusMsg.classList.remove('hidden');
                    document.getElementById('infoPanel').classList.add('hidden');
                } else {
                    // unexpected error
                    // alert(`Error loading cell data:\n${error.message}`);
                }
            }
        }

        function renderData(data) {
            // console.log("RenderData input:", data);
            if (currentLayer) {
                map.removeLayer(currentLayer);
            }

            // Create a feature group
            currentLayer = L.featureGroup().addTo(map);

            // Handle potential wrappers: data.content, data.features, or data itself
            let features = [];
            if (data.content && data.content.features) {
                features = data.content.features;
            } else if (data.features) {
                features = data.features;
            } else if (Array.isArray(data)) {
                features = data;
            }

            // console.log(`Found ${features.length} features to render.`);

            // Styles
            const polyStyle = {
                color: "#f87171", // red-400
                weight: 2,
                opacity: 1,
                fillOpacity: 0.3
            };

            features.forEach(cell => {
                if (cell.bbox && Array.isArray(cell.bbox) && cell.bbox.length > 0) {
                    // bbox is [[p1, p2], ...]
                    // We need to determine if it is [lat, lon] or [lon, lat]
                    // Heuristic: Lat must be [-90, 90]. Lon can be [-180, 180] or [0, 360].
                    // If p1 is not in [-90, 90], it is definitely Lon.
                    
                    const coords = cell.bbox.map(p => {
                        let val1 = p[0];
                        let val2 = p[1];
                        
                        let lat, lon;
                        
                        // Check if first value is out of valid lat range
                        if (Math.abs(val1) > 90) {
                             // Must be [lon, lat]
                             lon = val1;
                             lat = val2;
                        } else {
                             // Could be [lat, lon], or [lon, lat] if lon is within bounds.
                             // But given our domain (US), Lon is usually < -60 or > 230.
                             // So if p2 is large, it's definitely [lat, lon].
                             // If p2 is small (e.g. 35), and p1 is large (e.g. -96), it matches [lon, lat] logic above.
                             // If both are small? Unlikely for US storm cells.
                             
                             // Default to previous assumption [lat, lon] unless proven otherwise
                             lat = val1;
                             lon = val2;
                        }

                        // Normalize lon
                        if (lon > 180) lon -= 360; 
                        
                        return [lat, lon];
                    });

                    const polygon = L.polygon(coords, polyStyle);
                    
                    if (cell.properties) {
                        const props = { ...cell.properties, id: cell.id };
                        const content = Object.keys(props).map(k => `<b>${k}:</b> ${props[k]}`).join('<br>');
                        polygon.bindPopup(`<div class="text-xs max-h-40 overflow-auto">${content}</div>`);
                        
                        // Sidebar click
                        polygon.on('click', () => {
                             const infoPanel = document.getElementById('infoPanel');
                             const infoContent = document.getElementById('infoContent');
                             infoPanel.classList.remove('hidden');
                             infoContent.textContent = JSON.stringify(props, null, 2);
                        });
                    }
                    
                    polygon.addTo(currentLayer);
                }
            });

            // Fit bounds if has data (optional - disable to keep view stable for radar)
            // if (currentLayer.getLayers().length > 0) {
            //     map.fitBounds(currentLayer.getBounds(), { padding: [50, 50] });
            // } 
            // Better to keep view stable when scrubbing
        }
    </script>
</body>
</html>
